# QEMU Section Readme

this folder is for stuff needed to emulate the device

## Folder Structure
### Scripts
- `run_qemu.sh` starts a qemu vm (needs image generated by `create_rootfs_image.sh`)
- `run_qemu_initrd.sh` is an alternate version to `run_qemu.sh` that doesnt require root
- `run_qemu_usermode.sh` can run individual binaries emulating the XBurstR2 CPU
- `create_rootfs_image.sh` (requires sudo) bundles squashfs-root into an ext4 image for use with `run_qemu.sh`

### Other Files
- `initrd.cpio`, this is the initrd image for `run_qemu_initrd.sh`
- `rootfs-image`, this is the rootfs image for `run_qemu.sh`

## Current Debug Method
In order to get the kernel output from qemu youll need to use `gdb` (the GNU Debug Tool)
The outputs from this debugging have been put into the logs directory for analysis after being cleaned (there were a lot of useless lines)

1. run `run_qemu.sh` or `run_qemu_initrd.sh` to start the vm
2. run `gdb Linux-4.4.94+.elf` (you might need to change the path to the elf depending on your current directory). this opens up the gdb tool analyzing the kernel
3. now that you're in the gdb tool, run `target remote :1234`
4. run `continue`. wait for a pretty long while (like 10-30 seconds in my testing)
5. after a while it usually panics and automatically finishes the continue command. if it's been a long time it probably did panic but didnt stop the command for some reason
6. run `print __log_buf`
7. run `x/2000s __log_buf`, then type "c" and press enter to let it print out the whole log. this should show the kernel log, and end with a traceback from a panic. if it just ends at `random: nonblocking pool is initialized"`, then you probably didnt let it continue long enough.
8. save that log, it's useful. probably get rid of all the empty lines though
9. run `bt` to get a simple backtrace. ive not found it useful yet. but more info is more info.


## Problems/Todo
Currently, the kernel does not finish loading. I believe this is due to the incompatibility between the cpu (`XBurst2`) and the configured hardware (`malta`). The cpu is expecting timers, clocks, and devices, etc. that either dont exist on the malta or are at different addresses.

To fix this incompatibility and get the system emulation to work for emulating an XBurstR2 processor like the x1600e we need to add a new MIPS hardware option to qemu (another option like malta).
- The new qemu hardware should be heavily based on the halley6 development board, as it's built for use with the x1600 processors and very closely resembles the board on the HiBy OS devices
- The new qemu hardware should also base a lot of itsself off of the implementation of malta. Since malta does successfully initialize and start the kernel, only failing due to the SoC peripheral incompatibility

Useful resources:
- [a blog describing how someone added hardware and cpu support for a new architecture to qemu](https://fgoehler.com/blog/adding-a-new-architecture-to-qemu-01/). page 1 describes hardware, page 2 describes cpu
- Halley6 hardware develop documentation [original](documentation/Halley6_hardware_develop_V2.1.pdf) and [translated](documentation/Halley6_hardware_develop_V2.1.zh-CN_translated_EN.pdf)
- Halley6 [coreboard](documentation/halley6_coreboard_v2.0.pdf)/[baseboard](documentation/halley6_baseboard_v2.0.pdf) documentation
- [x1600e documentation](documentation/X1600_E+Data+Sheet.pdf)
